---
title: "Gap notebook"
output: Gap.nb.html
---
Load all csv files in Data

```{r, message=TRUE}
library(readr)
library(tibble)
library(dplyr)
DataDir = "~/GapExperiment/Data/"
load_csv <- function(fileName){
  filePath = paste0(DataDir, fileName)
  df = read_csv(filePath)
  names(df)[ncol(df)]  = "class"
  df$class = factor(df$class)
  return(df)
}
csvFiles = list.files(path = DataDir, pattern = "*.csv")
datasetNames = lapply(csvFiles, tools::file_path_sans_ext)
datasets = lapply(csvFiles, load_csv)
datasets = setNames(datasets, datasetNames)
names(datasets)
```
Create Synthesized datasets
```{r}
sampleGaussCluster <- function (muList, sigmaList, nEach){
  nCluster = length(muList)
  stopifnot(nCluster == length(sigmaList))
  df = NULL
  for (i in seq(nCluster)){
    sampMat = MASS::mvrnorm(n = nEach[[i]], muList[[i]], sigmaList[[i]])
    sampDf = as_data_frame(sampMat)
    sampDf$class = i
    if (is.null(df)){
      df = sampDf
    } else {
      df = rbind(df, sampDf)
    }
  }
  df$class = as.factor(df$class)
  return(df)
}

#2 overlapping Gaussian
set.seed(12347)
ovl2Gauss_Mu = list(c(0, 0), c(4, 0))
ovl2Gauss_Sigma = list(matrix(c(1,0.7,0.7,1),2,2), 
                      matrix(c(1, -0.7, -0.7, 1),2,2))
nEach = list(200, 200)
df = sampleGaussCluster(ovl2Gauss_Mu, ovl2Gauss_Sigma, nEach = nEach)
plot(df$V1, df$V2)
datasets[["ovl2Gauss"]] = df

#2 strong overlapping Gaussian
strOvl2Gauss_Mu = list(c(0, 0), c(2, 2))
strOvl2Gauss_Sigma = list(matrix(c(1,0.7,0.7,1),2,2), 
                      matrix(c(0.3, 0, 0, 0.5),2,2))
nEach = list(200, 200)
df = sampleGaussCluster(strOvl2Gauss_Mu, strOvl2Gauss_Sigma, nEach = nEach)
plot(df$V1, df$V2)
datasets[["strOvl2Gauss"]] = df

#3 overlapping Gaussian
set.seed(12345)
ovl3Gauss_Mu = list(c(0, 0), c(0, 8), c(0, 4))
ovl3Gauss_Sigma = list(matrix(c(1,0.7,0.7,1),2,2), 
                      matrix(c(1, 0.7, 0.7, 1),2,2),
                      matrix(c(1, -0.7, -0.7, 1), 2, 2))
nEach = list(200, 200, 200)
df = sampleGaussCluster(ovl3Gauss_Mu, ovl3Gauss_Sigma, nEach = nEach)
plot(df$V1, df$V2)
datasets[["ovl3Gauss"]] = df

#4 hierchical cluster
hier4Gauss_Mu = list(c(0, 0), c(3, 4), c(4, 3), c(3, 3))
hier4Gauss_Sigma = list(matrix(c(1,0,0,1),2,2), 
                        matrix(c(0.05, 0, 0, 0.05),2,2),
                        matrix(c(0.05, 0, 0, 0.05), 2, 2),
                        matrix(c(0.05, 0, 0, 0.05), 2, 2))
nEach = list(200, 100, 100, 100)
df = sampleGaussCluster(hier4Gauss_Mu, hier4Gauss_Sigma, nEach = nEach)
plot(df$V1, df$V2)
datasets[["hier4Gauss"]] = df

```

Function to run Gap
```{r}
library(dplyr)
library(cluster)
source("clusGap.R")

runGap <- function(df, 
                   df_name="None", 
                   B = 100,
                   FUNcluster = kmeans, 
                   pca = TRUE, 
                   method = "maxAcc",
                   do_parallel = TRUE,
                   SE.factor = 1,
                   K.max = 10,
                   ...){
  gap = clusGap(df %>% select(-class), 
                  FUN = FUNcluster, 
                  #nstart = 20, 
                  K.max = K.max,
                  #d.power = 2,
                  #spaceH0 = c("scaledPCA"),
                  pca = pca,
                  do_parallel = do_parallel,
                  B = B,
                  verbose = TRUE,
                  ...)
  tibs2001SEmax = maxSE(gap$Tab[, 3], gap$Tab[, 4], method="Tibs2001SEmax")
  firstSEmax =  maxSE(gap$Tab[, 3], gap$Tab[, 4], method="firstSEmax")
  accMax = maxSE(gap$Tab[, 3], gap$Tab[, 4], method="accMax")
  accMaxSE = maxSE(gap$Tab[, 3], gap$Tab[, 4], SE.factor = SE.factor, method="accMaxSE")
  firstAccMaxSE = maxSE(gap$Tab[, 3], gap$Tab[, 4], 
                        SE.factor = SE.factor, method="firstAccMaxSE")
  plot(gap, main = paste0(df_name, ": ", nlevels(df$class), ";", 
                          " tibs2001SE: ", tibs2001SEmax,
                          " firstSE: ", firstSEmax))
  mtext(paste0("accMax: ", accMax,
               " accMaxSE: ", accMaxSE,
               " firstAccMaxSE", firstAccMaxSE))
  print(paste("tibs2001SEmax:", tibs2001SEmax))
  print(paste("firstSEmax:", firstSEmax))
  print(paste("accMax:", accMax))
  print(paste("accMaxSE:", accMaxSE))
  print(paste("firstAccMaxSE:", firstAccMaxSE))
  #print(levels(df$class))
  return(list("gap"=gap, "kCluster"=firstAccMaxSE))
}

runGapRecursive <- function(df, SE.factor.start = 1, SE.factor.incr = 1,...){
  print("--------")
  kCluster = runGap(df, SE.factor = SE.factor.start, ...)$kCluster
  if (kCluster > 1){
    X = df%>%select(-class)
    #Always use pam
    clus = pam(X, kCluster)$cluster
    result = vapply(split(df, clus),
	      function(X) { #xs <- X[I,, drop=FALSE]
		              runGapRecursive(X, SE.factor.start*SE.factor.incr,SE.factor.incr, ...)}, 0.)
    print(result)
    return(sum(result))

  } else {
    return (kCluster)
    
  }
}
```
```{r}
names(datasets)
```

```{r}

df_name = 'mouse'
df = datasets[[df_name]]
#nums <- sapply(df, is.numeric)
#pam(df %>% select(-class), 3)
runGap(df, df_name, FUNcluster = kmeans, nstart = 30, pca = TRUE, method="accMaxSE", do_parallel = TRUE)

#Bootstrap
#df_sample = sample_n(df, size = min(nrow(df), 500), replace = TRUE)
#runGap(df_sample, df_name, FUNcluster = pam, pca = TRUE, method="accMaxSE", do_parallel = TRUE)
```

Test
```{r}
df_name = 'hier4Gauss'
df = datasets[[df_name]]
kCluster = 2
X = df%>%select(-class)
#X= as.matrix(X)
clus = pam(X, kCluster)$cluster
result = vapply(split(df, clus),
			      function(X) { #xs <- X[I,, drop=FALSE]
				                   runGap(X, df_name, FUNcluster = pam)$kCluster}, 0.)

```


```{r}
#GOOD DATA:
# Don't use bootstrap with small dataset!
# cancer: maxAcc fix; recursive without boot error; Recursive with boot help discover hidden structure
# glass: maxAcc + recursive (almost; 5 instead of 6)
# iris: maxAccSE + recursive fix. no boot, SE.factor.start = 0.5, SE.factor.incr = 1. Beautiful result!!!
#       Don't run Bootstrap: Nope! 
# seeds: all correct. no boot, SE.factor.start = 0.5, SE.factor.incr = 1
# vertebral_column: bootstrap fix!!
# wine: need maxAcc, maxAcc can't fix
# balance_scale: always 1, SE too big
# blood: always 1, maxAcc can't fix
# density: always good, no boot, SE.factor.start = 0.5, SE.factor.incr = 1
# liver-disorders: always 1
# mouse: missed, 4 -> predicted 3. Need recursive? (can't fix)
# pen: 10 classes, too big, linear increase
# skin: 2 classes, no hope
# lettr: no hope
# syn_unbalance3_5: good example for the usefulness of recursive and bootstrapping together, Tibs2001 and firstSE all make obvious mistakes! 
# hier4Gauss: recursive: no boot, SE.factor.start = 0.5, SE.factor.incr = 1
# ovl3Gauss: accMax: no boot, good example of overlapping SE.factor.start = 0.5, SE.factor.incr = 1 #Seed 12345
# strOvl2Gauss: accMax: no boot, SE.factor.start = 0.5, SE.factor.incr = 1 
# ovl2Gauss: no boot, firstSE and tibs2001SE wrong, firstAccMaxSE fix #Seed 12347
# aggregation: no boot, not good enough, 9 for 7 penalize with SE.factor.incr = 1.2
df_name = 's1'
df = datasets[[df_name]]
#df = sample_n(df, size = min(nrow(df), 800), replace = TRUE)
runGapRecursive(df, df_name=df_name, 
                FUNcluster = pam, 
                SE.factor.start = 0.5,
                SE.factor.incr = 1, 
                do_parallel=TRUE, 
                K.max = 18,
                #nstart=30, 
                B = 50,
                isBoot = TRUE,
                pca = FALSE,
                repBoot = 20,
                nBoot = 1000
                )
```